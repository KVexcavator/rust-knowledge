fn double_it(n: i32) -> i32 {
    n * 2
}

fn double_it(n: f32) -> f32 {
    n * 2.0
}

fn main() {
    println!("2 * 2 = {}", double_it(2));
}
/*вернет 
note: `double_it` must be defined only once in the value namespace of this module
For more information about this error, try `rustc --explain E0428`.

Rust проверяет только имя функции, поэтому даже при разных списках параметров
невозможно иметь две функции в одном пространстве имён с одинаковым именем.

Обобщения Rust(generics)
В Rust всё ещё можно создать функцию double_it, работающую с разными типами.
Вместо того, чтобы переопределять функцию, нужно использовать обобщённые типы.

fn double_it<T>(n: T) -> T
where T: std::ops::Mul<Output = T> + From<i32>
{
    n * 2.into()
}

fn main() {
    println!("2+2 = {}", double_it(2));
}

1. T добавляется как обобщённый тип к сигнатуре функции, а число для удвоения определяется как требующее тип T.
2. Обобщённые типы Rust ограничивают типы, с которыми может работать обобщённая функция, с помощью ключевого слова where. Вы можете разделять требования символами плюс.
- Первое ограничение требует, чтобы T реализовывал std::ops::Mul, то есть тип должен поддерживать оператор сложения, а результат умножения должен иметь тип T.
- Второе ограничение с помощью + From <i32>, требуя, чтобы входной тип мог быть сконструирован из целого числа. Если бы вы не требовали этого ограничения,* 2 не скомпилировался бы, поскольку Rust не мог бы гарантировать, что цифра 2 может быть преобразована в тип, совместимый с типом параметра функции.
3. В теле функции установили, что параметр n должен поддерживать умножение и быть совместимым с целым числом 2. Можно выполнить умножение, используя обычные операторы Rust.
 */