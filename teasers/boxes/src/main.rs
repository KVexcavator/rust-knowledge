
fn main() {
    let c = Box::new([0u32; 10_000_000]);
    println!("{}", c.len());
}
/*
Вернет в debug mode
thread 'main' has overflowed its stack
fatal runtime error: stack overflow
Aborted (core dumped)
Вернёт в release mode
10000000

Box::new([0u32; 10_000_000]) означает:
- 0u32 это литерал числа 0, у которого явно указан тип u32
- [0u32; 10_000_000]  → массив из десяти миллионов нулей типа u32
- Box::new — кладёт этот массив в кучу (heap)
-- Без Box массив на 10 млн элементов лежал бы на стеке, что вызвало бы stack overflow
-- С Box он помещается в heap и живёт там

Однако в режиме отладки Rust сначала выделяет массив в стеке, а затем перемещает его в кучу, что приводит к сбою программы.

Можно избежать исчерпания стековой памяти, используя Vec вместо массива.
Векторы всегда размещают своё содержимое в куче, что позволяет безопасно использовать гораздо большие наборы данных:
#[feature(box_syntax)]
fn main() {
    let x = vec![0u32; 10_000_000];
}

Решение проблемы переполнения стека с помощью оптимизации компилятора
При запуске примера в режиме релиза программа работает нормально. Это связано с тем,
что LLVM (компилятор Rust) достаточно умен, чтобы обнаружить выделение памяти, немедленно перемещаемое в кучу, и полностью пропустить выделение стека.

*/
