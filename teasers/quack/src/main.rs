fn double_it(n: u64, _: i32) -> u64 {
    n * 2
}
fn main() {
    let one: i32 = 1;
    let n = double_it(one as _, 3);
    println!("{}", n);
}
/*
вернуло 2

Символ подчёркивания в Rust имеет разные значения в разных контекстах:
- в качестве префикса имени переменной (например, _ignore_me : i32) подчёркивание указывает Rust, что переменная намеренно не используется, и подавляет предупреждения о «неиспользуемой переменной»
- в качестве полного имени переменной мы сообщаем Rust, что никогда не собираемся использовать эту переменную, например, _ => { .. } подчёркивание указывает на действие по умолчанию
- с функциями, возвращающими значение, помеченное #[must_use]. Например, let _ = my_important_function() проигнорирует результат функции, подавляя ошибки или предупреждения о том, что вы не используете результат

Выводная типизация(inferred typing)
При использовании с ключевым словом as символ _ указывает, что Rust должен попытаться преобразовать значение в любой ожидаемый в данном контексте тип. 
Например, function_that_requires_a_u32(x as _) попытается преобразовать x, независимо от его типа, в u32. Если x имеет тип, который невозможно преобразовать в u32, компилятор Rust
остановится с ошибкой.

Можете использовать as _, когда Rust уверен в нужном типе, но не рекомендуется использовать его в качестве первой точки вызова.
Порядок предпочтения преобразования типов:
1. into() обеспечивает точность и очень хорошую оптимизацию.
2. try_into() позволяет обрабатывать неудачные преобразования.
3. as _, когда вы уверены в безопасности преобразований.
4. as _, когда вы действительно застряли.
 */