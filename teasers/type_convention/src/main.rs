// #[warn(clippy::pedantic)]

fn main() {
    let x : u64 = 4_294_967_296;
    let y = x as u32;
    // println!("{:#?}", y); // возвращает 0
    if x == y as u64 {
        println!("x equals y.");
    } else {
        println!("x does not equal y.");
    }
}
/*
x does not equal y.
---
В этом примере переменной y присваивается значение 4_294_967_296, но результат усекается, поскольку это число больше максимального значения 32-битного беззнакового целого числа. Ни компилятор Rust, ни Clippy, ни среда выполнения не генерируют никаких предупреждений или ошибок о потере данных.
Правила:
• Преобразование меньшего типа в больший (например, u32 в u64) не может потерять точность, поэтому вы в безопасности.
• При работе с числами, которые гарантированно соответствуют обоим типам, вы не потеряете данные. Однако будьте осторожны с данными, предоставленными пользователями, или с  результатами вычислений — если вы не контролируете данные, вы не можете быть уверены, что они будут находиться в допустимых диапазонах.
• Будьте осторожны с преобразованиями чисел с плавающей точкой в ​​целые, поскольку Rust всегда округляет их в меньшую сторону. Учитывая это, лучше указать желаемое поведение с помощью my_float.floor() для округления в меньшую сторону, my_float.ceil() для округления в большую сторону или my_float.round() для выполнения обычного числового округления. Если вы хотите округлить, выполните округление до использования as.
---
Защита от потери точности
Rust предоставляет трейт Into для обеспечения безопасного преобразования типов во время компиляции:
let y = u32::max_value();
let z: u64 = y.into();
- преобразование u64 в u32 — с помощью Into невозможен

Ещё один трейт: TryInto:
use std::convert::TryInto;
let z: u32 = (5000_u64).try_into().expect("Ошибка преобразования");
Функция try_into() возвращает тип Result. Можно получить доступ к содержимому так же,
как и к другим типам Result. Например:
- развернуть содержимое и завершить работу, если преобразование не удалось.
- unwrap_or для подстановки значения по умолчанию.
- выполнить сопоставление с Result для явной обработки ошибки.
- использовать expect.

Что бы clippy обрабатывал такие случаи, можно добавить в начало файла
#[warn(clippy::pedantic)]
Педантичный Clippy сообщает о каждой потенциальной ошибке, которую замечает, — даже если она не вызывает проблем.
*/
