use std::cell::RefCell;
use std::rc::Rc;

type Link = Option<Rc<RefCell<Node>>>;

#[derive(Debug)]
struct Node {
    elem: i32,
    next: Link
}

fn main(){
    let mut head = Some(Rc::new(RefCell::new(Node{elem: 1, next: None})));

    head
        .as_mut()
        .unwrap()
        .borrow_mut()
        .next = Some(Rc::new(RefCell::new(Node{elem: 2, next: head.clone()})));

    println!("{:?}", head);
}

/*
Программа отобразит узел 1, узел 2, а затем снова узел 1. Вывод повторяется до тех пор, пока программа не завершится со следующим сообщением: поток 'main'
переполнил свой стек(утечка).

расшифровка типов:
- Rc<T> Reference counting — разделяемое владение.
Rc обеспечивает подсчёт ссылок. При вызове get для доступа к Rc счётчик ссылок увеличивается на 1. Аналогично, при удалении ссылки счётчик уменьшается на 1. Когда у Rc больше нет ссылок, его содержимое удаляется. С помощью Rc вы можете безопасно ссылаться на содержащуюся в нём структуру из других структур и гарантировать, что его содержимое будет удалено после завершения работы с ним.
- RefCell<T>  предоставляет изменяемую ячейку памяти и делает проверку заимствования динамической, а не статической. Когда вы заимствуете содержимое RefCell, Rust отмечает, что заимствование произошло во время выполнения, а не во время компиляции. Хотя второе изменяемое заимствование всё ещё может завершиться неудачей, это произойдёт как ошибка времени выполнения, а не компиляции.
- type Link = Option<Rc<RefCell<Node>>>;
Ссылка на следующий узел списка.
- None — конец списка.
- В Option<Rc<RefCell<Node>>> происходит следующее:
as_mut() — даёт доступ к содержимому Option по &mut
unwrap() — достаёт ссылку &mut Rc<...>
borrow_mut() — заходит внутрь RefCell и даёт RefMut<Node>
Дальше можно менять поля Node: .borrow_mut().next = ...

При совместном использовании Rc и RefCell создают динамическую структуру сборки мусора. Благодаря этой «мощной паре» можно обращаться к отдельным узлам, будучи уверенными, что ваши узлы будут удалены, когда они больше не нужны (на них ссылаются).
Rc и RefCell также удобны, когда нужно создать потенциально циклические структуры данных, которые могут быстро перегрузить гарантированные проверки безопасности Rust.
В этом случае, вместо того, чтобы заимствовать весь список при доступе к узлу, можно динамически заимствовать каждый элемент по мере необходимости. А благодаря подсчёту ссылок вы гарантируете окончательное уничтожение неиспользуемых узлов.
---
Пример аварийно завершается, поскольку создаёт циклическую ссылку, где следующий элемент первого узла указывает обратно на первый узел, что приводит к тому, что итерация списка продолжается бесконечно.
Rust не может удалить эту структуру из памяти, поскольку узлы сохраняют
ссылки друг на друга, что не приводит к четкому концу списка.
---
Можно избежать этого конкретного сбоя, определив собственную систему отладки, которая не выводит следующий узел. Не забудьте удалить #[derive(Debug)] из определения узла:
//#[derive(Debug)]
struct Node {
    elem: i32,
    next: Link,
}
use std::fmt;
impl fmt::Debug for Node {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "elem: {}", self.elem)
    }
}

Другой вариант не поймать эту ошибку, использовать std::collections::LinkedList стандартной библиотеки Rust.
Тестирование показывает, что Vec превосходит LinkedList практически во всех тестах. Даже его основное преимущество — вставка элемента в середину списка — выполняется медленнее, чем вставка элемента в вектор с последующей сортировкой данных.
 */
