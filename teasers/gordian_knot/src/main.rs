#[derive(Debug)]
struct Parser<'a>{
    body: String,
    subtext: &'a str,
}

fn main() {
    let mut document = Parser {
        body: "Hello".to_string(),
        subtext: ""
    };

    document.subtext = &document.body;

    let b = document;
    println!("{:?}", b);
}
/*
вернет
error[E0505]: cannot move out of `document` because it is borrowed
---
Удивительно, что компилятор доходит почти до конца кода, прежде чем сообщает об ошибке в предпоследней строке
---
В этом примере:
- для самой структуры указано время жизни: struct Parser<'a>. Время жизни структуры привязано к сохранённой ссылке: subtext : &'a str.
- часть структуры Parser присваивается другой части самой себя: a.subtext = &a.body; 
---
После того, как document присваивается самоссылка, он оказывается в необычном состоянии: он остаётся допустимым, но не может быть изменён. 
В результате вступают в силу следующие ограничения безопасности Rust:
- Время жизни <'a> требует, чтобы элемент body структуры оставался допустимым. Удаление body аннулирует пожизненную гарантию для subtext.
- Проверка заимствований запоминает, что subtext неизменяемо заимствует body. Любая попытка изменить body, включая его изменение или удаление, завершится неудачей.
---
Развязывая Гордиев узел
```
fn main() {
    {
        let mut a = Parser {
            body: "Hello".to_string(),
            subtext: ""
        };
        a.subtext = &a.body;
    }
}
Rust понимает, что вся структура исчезает, когда покидает активную область видимости,
и уничтожает её одним махом
---
Зачем использовать самоссылающиеся структуры?
Если ваша структура содержит большой объём данных, хранение ссылок на часть сохранённых данных может быть очень полезным. Вот несколько советов:
- Рассмотрите возможность выделения самоссылающихся систем в отдельные структуры, ссылающиеся на родительскую переменную. Такое решение делает удаление объектов явным: вы можете безопасно удалить дочерний объект в любой момент, но защита от времени жизни Rust по-прежнему гарантирует, что родительский объект должен пережить своих дочерних.
- Ограничьте использование самоссылающихся объектов короткоживущими областями, которые можно безопасно удалить.
- Если вы ссылаетесь на данные индекса, вы можете хранить индекс, на который
ссылаетесь, а не прямую ссылку/указатель на ссылающиеся данные. 
- Если всё остальное не помогает, используйте подсчёт ссылок (Rc) и слабые указатели, чтобы распутать ваши данные.
 */