fn main() {
    loop {
        let buffer = (0..1000).collect::<Vec<u32>>();
        std::mem::forget(buffer);
        print!(".");
    }
}
/*
возвратит 
.
Этот код создаёт вектор, намеренно теряет его, и печатает точку ".":
let buffer = (0..1000).collect::<Vec<u32>>();
Создаётся Vec<u32> из 1000 чисел: 0,1,2,...,999.
buffer хранит указатель на выделенную в куче память
std::mem::forget() — отключает деструктор
Эта функция принимает значение, но не вызывает его drop(), и не освобождает память.
Объект как бы убегает из области видимости, но не уничтожается.
Утечка здесь маленькая (~4 KB), так что не критично.
Но если делать это в цикле, получится реальная утечка памяти.

Использование std::mem::drop обычно очищает память и является предпочтительным подходом.

При обычном использовании Rust по умолчанию помогает избежать утечек памяти. Когда переменная «выпадает» из области видимости, автоматически вызывается её деструктор.
{
let my_vec = vec![100; 100];
}
эквивалентно
let my_vec = vec![100; 100];
std::mem::drop(my_vec);

Иногда нужно забыть(forget)
Например, если вы открыли дескриптор файла (с помощью File::open) и немедленно
передали этот дескриптор другому приложению, вам нужно забыть дескриптор, чтобы
ваша программа не закрыла его, сделав недействительным доступ второй программы.
 */
