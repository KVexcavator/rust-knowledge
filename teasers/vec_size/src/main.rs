fn main() {
    let mut my_vec = Vec::with_capacity(1);
    my_vec.push("Hello");
    println!("{}", my_vec.capacity());
    my_vec.push("World");
    println!("{}", my_vec.capacity());
}
/*
вернет
1
4
--
Векторы содержат две составляющие: 
- длину, указывающую количество элементов (элементов), хранящихся в векторе, и 
- буфер непрерывной динамической памяти, содержащий данные для каждого из элементов, один за другим. 
Этот буфер часто превышает общее количество элементов, хранящихся в векторе.
Ёмкость(capacity) представляет собой общий размер вектора.

В примере вызов Vec::with_capacity(1) создаёт новый вектор с достаточной ёмкостью для одного элемента. Затем он добавляет в вектор новую запись («Hello»), используя этот слот и заполняя вектор. На этом этапе вектор не знает, потребуется ли ему когда-либо снова увеличивать свою ёмкость, поэтому он остаётся равным 1. Затем код добавляет ещё одну новую запись («World») в вектор; однако на этот раз места нет, поэтому вектор добавляет ещё три пробела для будущего роста, что приводит к ёмкости 4.

При работе с векторами надо иметь в виду несколько моментов:
- Если есть приблизительное представление о том, сколько данных может понадобиться хранить, то использовать Vec::with_capacity, чтобы заранее зарезервировать необходимое количество памяти — это позволит полностью избежать перераспределения памяти.
- Если добавляется много данных, то стоит попробовать использовать Vec::extend, чтобы Rust мог видеть размер добавляемых данных и перераспределять память только один раз. extend позволяет избежать выделения памяти только при сборе данных из источника с известной длиной.
• Стоит добавлять элементы в конец векторов с помощью push, а не в определённую
слоту с помощью insert. Хотя вставка даёт больше контроля, она гораздо медленнее,
чем push, поскольку Rust необходимо перестроить вектор, чтобы освободить место для
нового элемента. Если вам нужно вставить элемент в начало, структура VecDeque
будет лучшим выбором.
 */
