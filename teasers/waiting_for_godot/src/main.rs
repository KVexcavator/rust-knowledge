async fn hello(){
    println!("Hello, world!")
}

#[tokio::main]
pub async fn main() -> Result <(), Box<dyn std::error::Error>>{
   hello();
   Ok(()) 
}
/*
ничего не вернет, только варнинг
warning: unused implementer of `Future` that must be used
--> src/main.rs:7:4...hello();
--- 
Вызов функции с асинхронным декором не приводит к её выполнению, а упаковывает её для будущего выполнения.
---
Жизненный цикл асинхронной функции:
1. создание асинхроннщй функции
async fn my_function() { ... }
2. выполнение функции создаёт Future, оборачивая функцию обещанием её будущего выполнения.
let promise = my_function() // Возвращает Future<my_function>, my_function ещё не выполняется!
3. дабавление Future<my_function> в очередь задач исполнителя:
my_function().await
- можно использовать любой из этих методов 
    spawn(promise)
    join!(promise, -other futures-)
    select!(promise, -other futures-)
---
При вызове async функции, функция не запускается автоматически. Вместо этого она возвращает переменную, реализующую Future trait. 
Future — основной строительный блок асинхронного программирования. Создавая Future, мы указываем, что ваша задача упакована и готова к выполнению. 
Создав Future, мы можем:
- Вызвать spawn, чтобы добавить задачу в очередь задач исполнителя и не ждать ответа.
- Дождаться результата от задачи, передав управление другим задачам, пока результат не будет доступен.
- Использовать join для одновременного выполнения нескольких задач и ожидания их завершения.
- Вызвать select, чтобы выполнить несколько задач и продолжить, когда одна из них вернет результат.
---
Что бы исполнить Hello:
#[tokio::main]
pub async fn main() -> Result<(), Box<dyn std::error::Error>> {
    hello().await;
    Ok(())
}
await указывает исполнителю Tokio приостановить выполнение задачи и начать выполнение функции hello. 
Когда функция hello() завершает выполнение, функция передаёт управление основной функции, которая затем завершается.
 */
