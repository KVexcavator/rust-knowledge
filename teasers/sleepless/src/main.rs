use tokio::join;
use std::time::Duration;

async fn count_and_wait(n: u64) -> u64 {
    println!("Starting {}", n);
    std::thread::sleep(Duration::from_millis(n*100));
    println!("Returning {}", n);
    n
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Join запускает несколько задач одновременно и возвращает управление, когда все они завершат выполнение.
    // при этом следующая стартует тогда, когда завершиться предыдущая
    join!(count_and_wait(1), count_and_wait(2), count_and_wait(3));
    Ok(())
}
/*
здесь
```Cargo.toml
tokio = {version = "1.7", features = ["full"]}
```
вернет:
Starting 1
Returning 1
Starting 2
Returning 2
Starting 3
Returning 3
- Макрос join обещает запустить три экземпляра count_and_wait одновременно, но вывод показывает, что задачи выполняются последовательно
---
Асинхронные (будущие) задачи — это не то же самое, что потоковые задачи
В поточной модели каждая задача выполняется внутри полноценного потока, поддерживаемого операционной системой. Потоки планируются независимо от других потоков и процессов. Асинхронная модель сохраняет задачи в очереди задач и выполняет их до тех пор, пока они не передадут управление исполняемой программе.
---
 */

// Потоки планируются операционной системой с упреждением. Пока поток приостановлен, другие потоки продолжают выполняться. Чисто потоковая версия этого тизера выглядит так:
use std::thread;
use std::time::Duration;

fn count_and_wait(n: u64) -> u64 {
    println!("Starting {}", n);
    std::thread::sleep(Duration::from_millis(n * 100));
    println!("Returning {}", n);
    n
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Потоки начинают работать сразу после вызова Thread::spawn
    let a = thread::spawn(|| count_and_wait(1));
    let b = thread::spawn(|| count_and_wait(2));
    let c = thread::spawn(|| count_and_wait(3));
    a.join().unwrap();
    b.join().unwrap();
    c.join().unwrap();
    Ok(())
}
/*
вернет 
Starting 1
Starting 2
Starting 3
Returning 1
Returning 2
Returning 3
 */

/*
Асинхронные задачи планируются совместно. Операционная система не вмешивается, чтобы гарантировать, что каждый поток получит справедливое распределение времени выполнения.
Задачи выполняются до тех пор, пока не передадут управление. Передача управления возвращает исполнителю — коду, ответственному за поддержку асинхронной среды. 
Задачи уступают управление, когда:
- Задача возвращает результат (сообщение об ошибке или значение).
- Задача завершает выполнение.
- Задача ожидает одну или несколько задач.
- Задача явно вызывает yield_now(), приостанавливая себя до тех пор, пока исполнитель не возобновит её выполнение.
--
Aсинхронное выполнение актуально для программ, связанных с вводом-выводом, — программ, которым приходится ждать завершения баз данных, файлов на диске или других процессов.
---
С асинхронными задачами надо избегать блокирующих вызовов. 
Блокирующие вызовы приостанавливают
выполнение процесса и возобновляют его после завершения. 
---
Блокирующие вызовы не возвращают управление исполнителю — вызов Thread::sleep
приостанавливает выполнение всего потока, включая исполнителя. 
Именно поэтому пример программы выполняется последовательно, хотя макрос join обещает
параллелизм.
Если заменить в функции count_and_wait в Thread::sleep следующим кодом:
tokio::time::sleep(Duration::from_millis(n*100)).await;
Будет тот же вывод, что и в потоковой версии, программа выполнялся параллельно.
---
Асинхронные блокирующие задачи
spawn_blocking сообщает Tokio, что  задача будет заблокирована, и Tokio создаст её внутри своего собственного потока, приостанавливая текущую задачу до тех пор, пока поток не завершит работу.
let blocking_task = tokio::spawn_blocking(|| {
    ... что-нибудь очень медленное и блокирующее
});
... запуск задачи
blocking_task.await.unwrap();
---
Длительные асинхронные задачи
async fn my_big_task() {
    for i in 0..1_000_000 {
        ... что-нибудь интенсивное с i
        tokio::task::yield_now();
    }
}
---

 */