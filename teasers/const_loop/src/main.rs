const fn fib(n: u128) -> u128 {
    let mut a = 1;
    let mut b = 1;
    for _ in 2..n {
        let tmp = a + b;
        a = b;
        b = tmp;
    }
    b
}
fn main() {
    for i in 0..5 {
        println!("Fib {} = {}", i, fib(i))
    }
}
/*
вернет
cannot use `for` loop on `std::ops::Range<u128>` in constant functions
 --> src/main.rs:4:14 
for _ in 2..n 
---
const функции запускаются во время компиляции, а не во время выполнения, компилятор заранее вычисляет результаты на основе константных входных данных, что может ускорить сложные вычисления.
Предположим, программа требует большого количества чисел Фибоначчи. Без константной функции программе пришлось бы пересчитывать эти числа по мере необходимости. Однако, используя константную функцию, можно хранить эти числа как константные значения в своей программе, что значительно улучшает её производительность.
Константные функции в Rust постепенно становятся более мощными. 
Однако на lfyysq момент vы не можетеv использовать следующие функции Rust внутри константной функции:
- Операции с плавающей точкой (можно перемещать их, но не можете работать с ними).
- Динамические типы данных.
- Обобщённые ограничения для параметров, отличных от Sized.
- Операции с необработанными указателями.
- Доступ к полям объединения (перечисления)- вот for не работет в примере выше
- Преобразование и аналогичные операции с памятью.
---
Вот рабочая версия const fn с while:
const fn fib(n: u128) -> u128 {
    let mut a = 1;
    let mut b = 1;
    let mut counter = 2;
    while counter < n {
        let tmp = a + b;
        a = b;
        b = tmp;
        counter += 1;
    }
    b
}
fn main() {
    for i in 0..5 {
        println!("Fib {} = {}", i, fib(i));
    }
}
---
Использование константных функций
- Программы часто полагаются на результаты сложных вычислений с ограниченным набором входных данных.
- Программа опирается на предопределённый фрагмент математических вычислений, но демонстрация работы может помочь объяснить, что делает ваша программа. 
 */
