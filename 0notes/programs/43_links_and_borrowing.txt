Ссылки и заимствование
============================
Возвращение владения параметрами
fn main() {
  let s1 = String::from("hello");
  let (s2, len) = calculate_length(s1);
  println!("Длина '{}' равна {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
  let length = s.len(); // len() возвращает длину экземпляра типа String
}

Что делать, если мы хотим позволить функциям ис­пользовать значение, но не брать его во владение?

fn main() {
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  println!("Длина '{}' равна {}.", s1, len);
}
fn calculate_length(s: &String) -> usize {
  s.len()
}

В функцию calculate_length мы передаем &s1 и для ее определения берем не String, а &String.
Оператор референции - &.
Амперсанды являются ссылками, они позволяют ссылаться на некое значение, не беря его во владение.
Использование ссылок в качестве функциональных параметров. назвается за­имствованием.
---------------------------------
Ссылки, точно так же, как и переменные, по умолчанию неизменяемы. Нельзя модифицировать то, на что есть ссылка.

fn main() {
  let s = String::from("hello");
  change(&s);
}

fn change(some_string: &String) {
  some_string.push_str(", world"); => Error
}
-------------------------
Изменяемые ссылки

fn main() {
  let mut s = String::from("hello");
  change(&s);
}

fn change(some_string: &mut String) {
  some_string.push_str(", world"); 
}
---------------------
Может быть только одна изменяемая ссылка на отдельный фрагмент данных в отдельной об­
ласти видимости
{
  let mut s = String::from("hello");
  let r1 = &mut s; => Error
  let r2 = &mut s; => Error
}
* Rust предотвращает гонку данных во время компиляции

Пример кравильного подхода:
  let mut s = String::from("hello");
  {
    let r1 = &mut s;
  } // r1 здесь выходит из области видимости, поэтому мы можем без проблем сделать
    // новую ссылку.
  let r2 = &mut s;
---------------------
Схожее правило существует для комбинирования изменяемых и неизменяемых ссылок.

  let mut s = String::from("hello");
  let r1 = &s; // нет проблем
  let r2 = &s; // нет проблем
  let r3 = &mut s; // БОЛЬШАЯ ПРОБЛЕМА
  println!("{}, {}, and {}", r1, r2, r3);
-----------------------
Висячие ссылки
Ссылки на место в памяти, которое, возможно, было отда­но кому-то другому
В Rust, компилятор гарантирует, что ссылки никогда не будут висячими.