Управление растущими проектами с помощью пакетов, упаковок и модулей
==============================
Пакеты
  Пакетный менеджер Cargo, который позволяет создавать, тестировать и со­ вместно использовать упаковки.
Упаковки
  Дерево модулей, которое производит библиотеку или исполняемый файл.
Модули и use
  Позволяют управлять организацией, областью видимости и приватностью путей.
Пути
  Способ именования элемента, такого как структура, функция или модуль.
============================
Пакеты и упаковки
----------------------------
Упаковка (crate) — это двоичный или библиотечный файл. 
----------------------------
Корень упаков­ки (crate root) — это исходный файл, с которого компилятор Rust начинает работу,
он составляет корневой модуль упаковки 
---------------------------
Пакет — это одна или несколько упаковок, которые обеспечивают функциональность. Пакет содержит файл Cargo.toml, который описывает то, как
создавать эти упаковки.
==========================
По соглашению
src/main.rs упаковочный корень
src/lib.rs библиотечная упаковка
---------------------------
Если в пакете есть src/main.rs и src/lib.
rs, то он имеет две упаковки: библиотечную и двоичную — обе с тем же именем, что и пакет. Пакет может иметь несколько двоичных упаковок, помещая файлы в каталог src/bin: каждый файл будет отдельной двоичной упаковкой.
============================
Определение модулей для управления областью
видимости и конфиденциальностью
----------------------------
use вводит путь в область видимости
pub делает элементы публичными
self для относительного пути use
----------------------------
создать новую упаковку
cargo new --lib restaurant
============================
Пути для ссылки на элемент в дереве модулей
две формы:
- Абсолютный путь начинается с корня упаковки, используя имя упаковки либо литерал crate.
crate::...
- Относительный путь начинается с текущего модуля и использует self, super или идентификатор в текущем модуле.
-------------------------------
super похоже на начало пути файловой системы с помощью синтаксиса ...
================================
Обозначение структур и перечислений как публичных
- Если мы используем pub перед определением структуры, то делаем структуру публичной, но поля структуры все равно будут конфиденциальными. Можно сделать каждое поле публичным на индивидуальной  основе
- если мы сделаем перечисление публичным, то тогда все его варианты будут публичными
===================================
Создание идиоматических путей use удобно для бибилиотек
Пример, введение структуры HashMap в область видимости идиоматическим способом

use std::collections::HashMap;
fn main() {
  let mut map = HashMap::new();
  map.insert(1, 2);
}
==================================
Предоставление новых имен с помощью
ключевого слова as\
use std::io::Result as IoResult;
==================================
Реэкспорт имен с использованием pub
pub use crate::front_of_house::hosting;
* внешний код теперь может вызывать функцию add_to_waitlist с помощью hosting::add_to_waitlist
===================================
Использование внешних пакетов
Cargo.toml
[dependencies]
rand = "0.5.5"
затем в коде
use rand::Rng;
встренные пакеты тоже в коде раскрывают
use std::collections::HashMap;
===================================
Использование вложенных путей для очистки
больших списков use
вместо 
use std::io;
use std::cmp::Ordering;
можно
use std::{io, cmp::Ordering};
или вместо болших пакетов
use std::io;
use std::io::Write;
распаковать
use std::io::{self, Write};
=========================
Оператор glob
ввести в область видимости все публичные элементы
use std::collections::*;