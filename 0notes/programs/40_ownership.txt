Концепция владения
==================
В Rust управление памятью осуществляется через систему владения с набором правил, которые компилятор проверяет во время компиля­ции
То, где находится значение — в стеке или куче, — существенно влияет на то, как себя ведет язык.
-------------------
Стек хранит значения в том порядке, в котором он их получает, а удаляет значения в обратном порядке.
Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер.
Добавление данных называется вталкиванием в стек, а удаление данных называется выталкиванием из стека.
----------------
Данные, размер которых во время компиляции неизвестен или может измениться, должны храниться в куче. 
Когда вы помещаете данные в кучу, вы запрашиваете определенный объем пространства. Операционная система находит достаточно большое пустое место в куче, помечает его как используемое и возвращает указатель, являющийся адресом этого места. Такой процесс
называется выделением пространства в куче.
---------------
Вталкивание в стек происходит быстрее, чем выделение пространства в куче.
Доступ к данным в куче происходит медленнее, чем к данным в стеке.
---------------
Управление данными кучи является причиной существования владения
================
Правила владения
- Каждое значение в языке Rust имеет переменную, которая называется его вла­дельцем.
- В каждый момент времени может существовать только один владелец.
- Если владелец выйдет из области видимости, значение будет отброшено.
================
Область видимости — это диапазон внутри программы, для которого элемент является действительным.
{ // s здесь не действует; она еще не объявлена
  let s = "hello "; // s действует с этого момента и далее
  // что-то сделать с s
} // эта область закончилась, и s больше не действует
================
Строковый тип который может изменятся(и храниться в куче соотв.)
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() добавляет литерал к экземпляру типа String
println!("{}", s); // эта инструкция выводит `hello, world!`
Здесь:
- String::from запрос пямяти из ОС во время выполне­ния.
- память возвращается автоматически, как только переменная, которой она принадлежит, выходит из области видимости
================
Перемещение
let s1 = String::from("hello");
let s2 = s1;
Экземпляр типа String состоит из трех частей, хранимых в стеке:
- указателя на память
- длины - это объем памяти в байтах, который использует содержимое экземпляра типа String в настоящее время.
- емко­сти - это общий объем памяти в байтах, ко­торый экземпляр типа String получил от операционной системы
Содержимое же , храниться в куче.
Когда let s2 = s1, содержимое в куче не дублируется, только то что в стеке.
Возможен конфликт при удалении, потому что оба ссылаются на одно и тоже содержимое.
Поетому с s1 дропается сразу при передаче данных и становиться недействительной.
--------------------
Поэтому говорят
s1 перемещается в s2
=====================
Clone
Cделать копию данных из кучи, а не толь­ко данных из стека
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
=====================
Copy
Cделать копию только из стека
такие типы, как целые числа, размер которых во время компиляции известен, хранятся полностью в стеке
let x = 5;
let y = x;
println!("x = {}, y = {}", x, y);
Примерный список, типов поддерживающих Copy:
- Все целочисленные типы, такие как u32.
- Булев тип bool со значениями true и false.
- Символьный тип char.
- Все типы с плавающей точкой, такие как f64.
- Кортежи, если только они содержат типы, которые также аннотируются. На­пример, (i32, i32) аннотируются, а (i32, String) — нет.