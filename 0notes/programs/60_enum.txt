Перечисления
Перечисления
позволяют определять тип путем перечисления его возможных значений.
========================================
Допустим, нужно работать с IP-адресами.
enum IpAddrKind {
  V4,
  V6,
}
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
функция, которая принимает любой вариант IpAddrKind
fn route(ip_kind: IpAddrKind) { }
вызвать эту функцию с любым вариантом
route(IpAddrKind::V4);
route(IpAddrKind::V6);
=======================
для enum(как и для struct) можно определить методы
=======================
Перечисление Option и его преимущества по сравнению со значениями null
-----------------------
Тип Option кодирует сценарий, в котором значение может быть чем-то либо не может быть ничем
-----------------------
Язык Rust не имеет языкового оформления для null, но у него есть перечисление, которое кодирует идею
присутствующего или отсутствующего значения
enum Option<T> {
  Some(T),
  None,
}
* <T> означает, что вариант Some перечисления Option может содержать один фрагмент данных любого типа
------------------------
можно использовать Some и None непосредственно без пре­фикса Option::

let some_number = Some(5);
let some_string = Some("строковый литерал");
или отсутстующий номер
let absent_number = Option<i32> = None;
==========================
Выражение match как оператор управления потоком
--------------------------
Match позволяет сравнивать значение с серией паттернов, а затем исполнять код, основываясь на том, какой паттерн совпадает. 
Паттерны могут состоять из буквенных значений, имен переменных, подстановочных знаков и других элементов
---------------------------
Сопоставление с Option<T>
match x {
    None => None,
    Some(i) => Some(i + 1),
}
* в случае с Option<T>, когда Rust не даст забыть про обработку None
--------------------------
Заполнитель _
когда мы не хотим перечислять все возможные значения
_ будет соответствовать любому значению

let some_u8_value = 0u8;
match some_u8_value {
  1 => println!("один"),
  3 => println!("три"),
  5 => println!("пять"),
  7 => println!("семь"),
  _ => (),
}
=============================
Сжатое управление потоком с помощью if let
Синтаксис if let позволяет кратко совместить if и let для обработки значений, которые совпадают с одним паттерном, игнорируя остальные.
------------------------------
Пример 1:
вместо
let some_u8_value = Some(0u8);
  match some_u8_value {
  Some(3) => println!("три"),
  _ => (),
}
лучше
if let Some(3) = some_u8_value {
  println!("три");
}
-----------------------------
Пример 2:
вместо
let mut count = 0;
match coin {
  Coin::Quarter(state) => println!("Четвертак из штата {:?}!", state),
  _ => count += 1,
}
лучше
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("Четвертак из штата {:?}!", state);
} else {
    count += 1;
}