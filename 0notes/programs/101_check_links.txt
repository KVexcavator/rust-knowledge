Проверка ссылок с помощью жизненных циклов
=========================================
у каждой ссылки в Rust есть жизненный цикл, то есть протяженность, в тече­ние которой эта ссылка действительна
цель жизненного цикла — предотвращать висячие ссылки
----------------------------------------
Попытка использовать ссылку, значение которой вышло из области видимости
{
  let r;
  {
    let x = 5;
    r = &x;
  }
  println1("r: {}, r);
}
* error -> x живет недостаточно долго, области видимости не совпадают
--------------------------------------
Контролер заимствования
сравнивает об­ласти видимости, чтобы выяснить, являются ли все заимствования действитель­ными
--------------------------------------
Синтаксис аннотаций жизненных циклов
Аннотации жизненных циклов не изменяют протяженность жизни ссылки.
&i32 // ссылка
&'a i32 // ссылка с явно выраженным жизненным циклом
&'a mut i32 // изменяемая ссылка с явно выраженным жизненным циклом
---------------------------------
Аннотации жизненных циклов в сигнатурах функций

Определение функции longest, описывающее, что все ссылки в сигнатуре должны иметь одинаковый жизненный цикл 'a

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  if x.len() > y.len(){
    x
  } else {
    y
  }
}
* контролер заимствования должен отклонять любые значения, которые не соответствуют этим ограничениям
================================
Аннотации жизненных циклов в определениях структур
Структуры могут содержать ссылки, но в этом случае потребуется добавить ан­нотацию жизненного цикла в каждую ссылку в определении структуры.

struct ImportantExcerpt<'a> {
  part: &'a str
}
===================================
Пропуск жизненного цикла
в ранних версиях все анотировали
fn first_word<'a>(s: &'a str) -> &'a str {
сейчас можно пропустить аннотации
fn first_word(s: &str) -> &str

Чтобы выяснить, какие жизненные циклы есть у ссылок, когда нет явно заданных аннотаций, компилятор использует три правила.
======================================
Аннотации жизненных циклов в определениях методов
impl<'a> ImportantExcerpt<'a> {
  fn level(&self) -> i32 {
    3
  }
}
======================================
Статический жизненный цикл
особый жизненный цикл — 'static, который обозна­чает всю продолжительность программы
let s: &'static str = "hello...";
======================================
fn some<'a, T>(x: &ia str, y: &'a str, ann: T) -> &'a str
  where T:Display