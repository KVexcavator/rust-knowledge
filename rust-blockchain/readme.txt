План проекта
============
Структуры:

1.Block 
- timestamp
- previous_block_hash
- hash
- <Transaction> (вектор с многими*)
- nonce (уникальный номер)
- height (количество блоков, обрабатывающих этот блок в блокчейне)
* в векторе можно хранить другие структуры

2.Transaction
- id
- vin(<TXInput>) // вектор входящих транзакций
- vout (<TXOutput>) // вектор выходящих транзакции

3. TXInput
- txid // id транзакции
- vout // вектор TXOutput
- signature // подпись данных
- pub_key // публичный ключ для доступа к данным

4. TXOutput
- value // значение транзакции
- pub_key_hash // публичный хеш ключа
---
Стандартная транзакция состоит из входов и выходов. 
Выходы имеют первостепенное значение и представляют собой неделимые единицы криптовалюты (например, биткоина), которые регистрируются в распределённом реестре. Вся сеть признаёт эти выходы действительными, предоставляя их возможность быть потраченными. 
Исключением является Coinbase-транзакция, которая не имеет входа, но создаёт выход – то есть оплату майнеру за майнинг блока.
Когда происходит транзакция, например, когда A отправляет валюту B, она генерирует неизрасходованные выходы транзакции (UTXO). Эти UTXO связаны с адресом кошелька B и могут быть использованы B.
Сеть распределённых полных узлов отслеживает набор UTXO, известный как набор UTXO. Чтобы использовать полученные средства, B может потратить один или несколько UTXO из этого набора/пула UTXO.
---

5. Blockchain
- tip_hash // хаш поледнего блока
- db // база данных содержит всё дерево блоков и определяет, как блоки связаны

6. Wallet // для каждого юзера
- pksc8 // public key criptography standart - ключ по стандарту PKSC8
- public_key // публичный ключ кошелька ECDSA keypair исползуется для подписи транцакий и доступа к фондам
---
Допустим у пользователя есть кошелек, под капотом:
1. Генерация ключа: кошелек генерирует закрытый ключ, используя криптографический алгоритм, такой как RSA или ECDSA.
2. Сериализация: закрытый ключ затем сериализуется в формат PKCS8. Этот процесс включает в себя кодирование ключа в стандартную структуру, которая может включать дополнительные метаданные о ключе.
3. Шифрование (необязательно): ключ в формате PKCS8 также может быть зашифрован для дополнительной безопасности. Это означает, что даже если кто-то получит доступ к файлу PKCS8, он не сможет использовать закрытый ключ без парольной фразы.
4. Хранение: сериализованный (и, возможно, зашифрованный) закрытый ключ PKCS8 хранится в кошельке.
---

7. Node // хранят копии блокчейна
- address // обычно порта, если они находятся на одном сервере, или IP-адрес,если они находятся на разных серверах
---
Узлы — это независимые серверы, хранящие копию блокчейна. 
Некоторые узлы являются полными узлами, которые хранят полную копию блокчейна. 
В блокчейне присутствует множество узлов, если несколько узлов в сети выходят из строя,
остаётся ещё много узлов, которые будут поддерживать блокчейн 
---

8. Server // обслуживают весь блокчейн через несколько блоков или всё дерево блоков
- blockchain // struct blockchain

9. Proof of Work // механизм консенсуса «доказательство работы»
- block // struct block
- target // математический результат формулы, преобразованный в шестнадцатеричное число, которое определяет сложность майнинга

===
Функции
---
функции, которые должны сопровождать каждую структуру
например, все функции, связанные с блоком, будут находиться в файле блока
---
1. Block
- new_block // создание нового блока
- generate_genesis_block // блок генезиса — это самый первый блок в блокчейне, он не будет хранить предыдущее значение хеша
- hash_transactions // помогает хешировать транзакции, которые происходят и которые хранятся в блоке

2. Blockchain
- create_blockhain //
- update_block_tree //
- new_blockhain //
- mine_block //
- add_block //

3. Node
- add_node //
- evict_node // удаление
- get_nodes // все узлы
- node_is_known //

---
Сервер обслуживает весь блокчейн, и каждый узел может работать как сервер на отдельном порту. 
Узел в сети блокчейна относится к любому компьютеру, участвующему в работе сети.
Все серверы можно считать узлами, не все узлы являются серверами
Запуск узла в качестве сервера на отдельном порту подразумевает, что он предназначен для обработки определённых сетевых функций и обмена данными, что часто требует больше ресурсов и предлагает более широкие возможности, чем обычный узел
---

4. Server
- run // запуск сервера
- serve // принимает запросы от одноранговых узлов (узлов), а затем вызывает
другие функции, основываясь на условиях соответствия, таких как приём данных, верификация блоков и функции запуска валидных транзакций, для синхронизации, обеспечения целостности сети и достижения консенсуса между узлами
- send_data // получает данные из сокета
- send_block // объявить блок остальным узлам сети
- send_txn // объявить транзакцию остальным узлам сети

5. Transaction // основные данные, которые хранятся в блоках ииспользуются при переводе денег, валюты или ценностей между счетами
- verify // для проверки для каждой транзакции генерируется хеш, 
- sign // аккаунт, отправляющий транзакцию, должен подписать её своим ключом
- hash // cоздание хеша
- new_utxo_transaction // неизрасходованный вывод транзакции, поскольку у получателя транзакции будет больше денег на банковском счете, и он сможет потратить эти новые полученные деньги

6. Wallet
- new // создать новый кошелек
- get_Address // получает связанный адрес кошелька
- validate_address // проверяет, является ли адрес адресом кошелька, используя хеш открытого ключа
- convert_address // принимает открытый хеш ключа и возвращает строку

7. UTXO set // набор функций для неизрасходованных выводов
- find_spendable_outputs // помогает находить доступные для расходования UTXO
- find_utxo // находит неизрасходованные транзакции в полном дереве блокчейна
- count_transactions // подсчитывает количество выполненных транзакций
- reindex //
- update //

8. Memory pool // все транзакции, происходящие между аккаунтами в блокчейне, попадают в пул памяти, здесь они собираются и добавляются в блок узлами
- contains // cодержит ли пул памяти конкретную транзакцию
- add // для добавления транзакций в пул памяти
- get // извлечёт конкретную транзакцию с указанным значением tx_id из пула памяти
- remove // удаляет транзакции
- get_all //  все транзакции, находящиеся в данный момент в пуле памяти
===============